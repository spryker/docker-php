name: Generate Consolidated Release Notes

on:
  workflow_call:
    inputs:
      pr_body:
        description: 'The body of an open PR for testing purposes'
        required: false
        type: string
        default: ''

jobs:
  verify_workflow:
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.check.outputs.proceed }}
    steps:
      - id: check
        run: |
          echo "proceed=true" >> $GITHUB_OUTPUT

  calculate_diffs:
    needs: verify_workflow
    if: needs.verify_workflow.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        image_tag:
          - "8.1-alpine3.20"
          - "8.2-alpine3.20"
          - "8.3-alpine3.20"
          - "8.4-alpine3.20"
          - "8.2-alpine3.21"
          - "8.3-alpine3.21"
          - "8.4-alpine3.21"
          - "8.2-alpine3.22"
          - "8.3-alpine3.22"
          - "8.4-alpine3.22"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: üîé Find Last & Previous Job IDs for ${{ matrix.image_tag }}
        id: find_jobs
        run: |
          LATEST_RUN_ID=$(gh run list --workflow="Combined CI/CD, Security Scan & Release Notes" \
            --json databaseId,event,status,conclusion \
            -q '.[] | select(
              .status == "completed" and 
              .headSha == env.GITHUB_SHA
            ) | .databaseId' \
            --limit 1)
          
          if [[ -n "$LATEST_RUN_ID" ]]; then
            LATEST_JOB_ID=$(gh api "repos/${{ github.repository }}/actions/runs/$LATEST_RUN_ID/jobs" \
              --jq ".jobs[] | select(
                .name | contains(\"security-scan\") and 
                contains(\"matrix\") and 
                contains(\"${{ matrix.image_tag }}\")
              ) | .id")
            echo "Found security-scan job for ${{ matrix.image_tag }}: $LATEST_JOB_ID"
          fi
          
          SCHEDULED_RUN_ID=$(gh run list --workflow="ECR vulnerability detection" \
            --json databaseId,event,status \
            -q '.[] | select(
              .status == "completed" and 
              .event == "schedule"
            ) | .databaseId' \
            --limit 1)
          
          if [[ -n "$SCHEDULED_RUN_ID" ]]; then
            PREVIOUS_JOB_ID=$(gh api "repos/${{ github.repository }}/actions/runs/$SCHEDULED_RUN_ID/jobs" \
              --jq ".jobs[] | select(
                .name | contains(\"vulnerability-detection\") and 
                contains(\"matrix\") and 
                contains(\"${{ matrix.image_tag }}\")
              ) | .id")
            echo "Found scheduled scan job for ${{ matrix.image_tag }}: $PREVIOUS_JOB_ID"
          fi
          
          echo "latest_job_id=${LATEST_JOB_ID:-}" >> $GITHUB_OUTPUT
          echo "previous_job_id=${PREVIOUS_JOB_ID:-}" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_SHA: ${{ github.sha }}

      - name: üì• Fetch and Parse Logs for ${{ matrix.image_tag }}
        run: |
          if [[ -n "${{ steps.find_jobs.outputs.latest_job_id }}" ]]; then
            gh run view --job ${{ steps.find_jobs.outputs.latest_job_id }} --log > latest_raw.log
            awk "/cat <<'JSON'/{flag=1; next} /JSON/{flag=0} flag" latest_raw.log > latest-scan.json
          fi
          if [[ -n "${{ steps.find_jobs.outputs.previous_job_id }}" ]]; then
            gh run view --job ${{ steps.find_jobs.outputs.previous_job_id }} --log > previous_raw.log
            awk "/cat <<'JSON'/{flag=1; next} /JSON/{flag=0} flag" previous_raw.log > previous-scan.json
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üîÑ Compare Scans for ${{ matrix.image_tag }}
        id: compare
        run: |
          PREVIOUS_SCAN_FILE="previous-scan.json"
          CURRENT_SCAN_FILE="latest-scan.json"
          if [[ ! -f "$PREVIOUS_SCAN_FILE" ]]; then touch "$PREVIOUS_SCAN_FILE"; fi
          if [[ ! -f "$CURRENT_SCAN_FILE" ]]; then touch "$CURRENT_SCAN_FILE"; fi

          if ! jq . "$PREVIOUS_SCAN_FILE" >/dev/null 2>&1; then
            echo "Warning: Previous scan file was invalid. Creating empty placeholder."
            echo '{ "imageScanFindings": { "findings": [] } }' > "$PREVIOUS_SCAN_FILE"
          fi
          if ! jq . "$CURRENT_SCAN_FILE" >/dev/null 2>&1; then
            echo "Warning: Current scan file was invalid. Creating empty placeholder."
            echo '{ "imageScanFindings": { "findings": [] } }' > "$CURRENT_SCAN_FILE"
          fi
          
          FIXED_VULNS=$(jq -r --slurpfile current "$CURRENT_SCAN_FILE" \
            '.imageScanFindings.findings[] | select(.name as $cve | ($current[0].imageScanFindings.findings | map(.name) | index($cve) | not)) | "- **\(.name)**: \(.description)"' \
            "$PREVIOUS_SCAN_FILE")
            
          if [[ -z "$FIXED_VULNS" ]]; then
            echo "- No CVEs fixed in this release." > fixed_vulns.txt
          else
            echo "$FIXED_VULNS" > fixed_vulns.txt
          fi

          NEW_VULNS=$(jq -r --slurpfile previous "$PREVIOUS_SCAN_FILE" \
            '.imageScanFindings.findings[] | select(.name as $cve | ($previous[0].imageScanFindings.findings | map(.name) | index($cve) | not)) | "- **\(.name)** (\(.severity)): \(.description)"' \
            "$CURRENT_SCAN_FILE")

          if [[ -n "$NEW_VULNS" ]]; then
            echo -e "\n### New Vulnerabilities Found:" >> fixed_vulns.txt
            echo "$NEW_VULNS" >> fixed_vulns.txt
          fi

      - name: üì§ Upload Diff for ${{ matrix.image_tag }}
        uses: actions/upload-artifact@v4
        with:
          name: diff-${{ matrix.image_tag }}
          path: fixed_vulns.txt
            
  generate_notes:
    needs: calculate_diffs
    runs-on: ubuntu-latest
    outputs:
      release_date: ${{ steps.assemble.outputs.release_date }}
      last_updated_str: ${{ steps.assemble.outputs.last_updated_str }}
      publish_date: ${{ steps.assemble.outputs.publish_date }}
    steps:
      - name: üì• Download All CVE Diffs
        uses: actions/download-artifact@v4
        with:
          path: ./all-diffs

      - name: üì£ Get Merged PR Info
        id: pr-info
        uses: actions-ecosystem/action-get-merged-pull-request@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: üß† Determine which PR body to use
        id: determine_body
        env:
          INPUT_BODY: ${{ inputs.pr_body }}
          MERGED_BODY: ${{ steps.pr-info.outputs.body }}
        run: |
          FINAL_BODY=""
          if [[ -n "$INPUT_BODY" ]]; then
            echo "Using PR body provided via workflow input (testing mode)."
            FINAL_BODY="$INPUT_BODY"
          else
            echo "No PR body input provided. Using merged PR body (production mode)."
            FINAL_BODY="$MERGED_BODY"
          fi
          
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$FINAL_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: ‚úçÔ∏è Extract PR Sections
        id: extract
        env:
          PR_BODY_RAW: ${{ steps.determine_body.outputs.body }}
        run: |
          # Clean and normalize the PR body, remove checklist and steps sections
          PR_BODY=$(echo "$PR_BODY_RAW" | tr -d '\r' | sed '/^## Checklist/,$d' | sed '/^## Steps before you submit a PR/,$d')

          # Extract improvements (between ### Improvements and ### Security Fixes or ##)
          IMPROVEMENTS=$(echo "$PR_BODY" | awk '/^### Improvements/{flag=1;next} /^### Security Fixes|^##/{flag=0} flag')
          echo "improvements<<EOF" >> $GITHUB_OUTPUT
          echo "$IMPROVEMENTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Extract security fixes content (between ### Security Fixes and next ##)
          SECURITY_FIXES=$(echo "$PR_BODY" | awk '/^### Security Fixes/{flag=1;next} /^##/{flag=0} flag')
          echo "security_fixes<<EOF" >> $GITHUB_OUTPUT
          echo "$SECURITY_FIXES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üìú Assemble Release Notes
        id: assemble
        env:
          IMPROVEMENTS_CONTENT: ${{ steps.extract.outputs.improvements }}
          MANUAL_FIXES_RAW: ${{ steps.extract.outputs.security_fixes }}
        run: |
          RELEASE_DATE=$(date +'%Y%m%d')
          echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          
          PUBLISH_DATE=$(date +'%Y-%m-%d')
          echo "publish_date=$PUBLISH_DATE" >> $GITHUB_OUTPUT
          
          LAST_UPDATED_STR=$(date +'%B %d, %Y')
          echo "last_updated_str=$LAST_UPDATED_STR" >> $GITHUB_OUTPUT

          # Generate automated security fixes from scan diffs
          AUTOMATED_FIXES_BODY=""
          HAS_AUTOMATED_FIXES=false
          NO_CVES_STRING="- No CVEs fixed in this release."
          for dir in ./all-diffs/*/; do
            IMAGE_TAG=$(basename "$dir" | sed 's/diff-//')
            FIXED_CVES=$(cat "${dir}/fixed_vulns.txt")
            if [[ "$(echo "$FIXED_CVES" | xargs)" != "$NO_CVES_STRING" ]]; then
              AUTOMATED_FIXES_BODY+=$(printf '\n**spryker/php:%s** (Automated Scan)\n%s' "$IMAGE_TAG" "$FIXED_CVES")
              HAS_AUTOMATED_FIXES=true
            fi
          done

          # Check if manual security fixes have actual content (not just whitespace/empty lines)
          MANUAL_FIXES_TRIMMED=$(echo "$MANUAL_FIXES_RAW" | sed '/^$/d' | tr -d '[:space:]')

          # Build security fixes section - only if there's automated fixes OR manual content
          SECURITY_SECTION=""
          if [ "$HAS_AUTOMATED_FIXES" = true ] || [ -n "$MANUAL_FIXES_TRIMMED" ]; then
            FINAL_SECURITY_TEXT=""
            if [ "$HAS_AUTOMATED_FIXES" = true ]; then
              FINAL_SECURITY_TEXT+="${AUTOMATED_FIXES_BODY}"
            fi
            if [ -n "$MANUAL_FIXES_TRIMMED" ]; then
              if [ "$HAS_AUTOMATED_FIXES" = true ]; then
                FINAL_SECURITY_TEXT+="\n"
              fi
              FINAL_SECURITY_TEXT+="\n${MANUAL_FIXES_RAW}"
            fi
            SECURITY_SECTION="

          ### Security fixes ${FINAL_SECURITY_TEXT}"
                    fi

                    # Create release notes file
                    cat << EOF > release-notes-new-file.md
          ---
          title: Release notes for spryker-php $RELEASE_DATE
          description: This document describes the changes that have been recently released.
          last_updated: $LAST_UPDATED_STR
          template: concept-topic-template
          publish_date: "$PUBLISH_DATE"
          ---

          This document describes the changes that have been recently released.
          For additional support with this content, contact our support.
          If you found a new security vulnerability, contact us at **security@spryker.com**.

          ---

          ## Release notes for spryker-php $RELEASE_DATE

          **Improvements**:

          $IMPROVEMENTS_CONTENT${SECURITY_SECTION}
          EOF

          echo "::group::üìú New Release Notes File"
          cat release-notes-new-file.md
          echo "::endgroup::"

      - name: üì§ Upload Release Notes Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes-artifact
          path: release-notes-new-file.md

  create-release-pr:
    name: üìÑ Create Release Notes PR in Docs Repo
    needs: generate_notes
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
    steps:
      - name: üì• Download Release Notes Artifact
        uses: actions/download-artifact@v4
        with:
          name: release-notes-artifact

      - name: Checkout Documentation Repository
        uses: actions/checkout@v4
        with:
          repository: spryker/spryker-docs
          token: ${{ secrets.DOCS_REPO_PAT }}
          path: docs-repo

      - name: üìù Create New Release Notes File
        run: |
          RELEASE_DATE="${{ needs.generate_notes.outputs.release_date }}"
          TARGET_DIR="./docs-repo/docs/about/all/releases/image-releases/spryker-php"
          TARGET_FILE="$TARGET_DIR/release-notes-spryker-php-$RELEASE_DATE.md"
          
          echo "Creating new release notes file: $TARGET_FILE"
          mkdir -p "$TARGET_DIR"
          
          cp release-notes-new-file.md "$TARGET_FILE"
          echo "‚úÖ Created $TARGET_FILE"

      - name: üìã Update Sidebar Navigation
        run: |
          RELEASE_DATE="${{ needs.generate_notes.outputs.release_date }}"
          SIDEBAR_FILE="./docs-repo/_data/sidebars/about_all_sidebar.yml"
          
          echo "Updating sidebar: $SIDEBAR_FILE"
          
          # Check if Spryker-PHP section exists under Image releases
          if ! grep -q "title: Spryker-PHP" "$SIDEBAR_FILE"; then
            echo "‚ö†Ô∏è Spryker-PHP section does not exist in sidebar. Please create it manually first."
            echo "Expected to find: 'title: Spryker-PHP' under 'Image releases'"
            echo ""
            echo "Please add the following structure to the sidebar under 'Image releases':"
            echo "        - title: Spryker-PHP"
            echo "          nested:"
            exit 1
          fi
          
          echo "‚úÖ Spryker-PHP section found, adding new entry..."
          
          echo "::group::üìã Current Spryker-PHP section (before update)"
          grep -A 10 "title: Spryker-PHP" "$SIDEBAR_FILE" | head -15
          echo "::endgroup::"
          
          SPRYKER_PHP_LINE=$(grep -n "^\s*- title: Spryker-PHP$" "$SIDEBAR_FILE" | head -1 | cut -d: -f1)
          
          if [ -z "$SPRYKER_PHP_LINE" ]; then
            echo "‚ùå Could not find Spryker-PHP section line number"
            exit 1
          fi
          
          echo "Found Spryker-PHP section at line: $SPRYKER_PHP_LINE"
          
          INSERT_LINE=$((SPRYKER_PHP_LINE + 2))
          
          echo "Inserting new entry at line: $INSERT_LINE"
          
          # Create temp file with new entry (10 spaces before -, 12 spaces before url)
          printf "          - title: Release notes for spryker-php %s\n            url: /docs/about/all/releases/image-releases/spryker-php/release-notes-spryker-php-%s.html\n" "$RELEASE_DATE" "$RELEASE_DATE" > /tmp/new_entry.txt
          
          # Insert the new entry
          head -n $((INSERT_LINE - 1)) "$SIDEBAR_FILE" > /tmp/sidebar_temp.yml
          cat /tmp/new_entry.txt >> /tmp/sidebar_temp.yml
          tail -n +$INSERT_LINE "$SIDEBAR_FILE" >> /tmp/sidebar_temp.yml
          mv /tmp/sidebar_temp.yml "$SIDEBAR_FILE"
          
          echo "‚úÖ Added new entry to Spryker-PHP section at line $INSERT_LINE"
          
          echo "::group::üìã Updated Spryker-PHP section (after update)"
          grep -A 15 "title: Spryker-PHP" "$SIDEBAR_FILE" | head -20
          echo "::endgroup::"

      - name: üöÄ Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.DOCS_REPO_PAT }}
          path: ./docs-repo
          commit-message: "docs: Add release notes for spryker-php ${{ needs.generate_notes.outputs.release_date }}"
          branch: "docs/docker-images/release-notes-spryker-php-${{ needs.generate_notes.outputs.release_date }}"
          title: "Release Notes for spryker-php ${{ needs.generate_notes.outputs.release_date }}"
          body: |
            This PR contains the release notes for spryker-php ${{ needs.generate_notes.outputs.release_date }}.
            
            **Changes:**
            - Created new release notes file: `release-notes-spryker-php-${{ needs.generate_notes.outputs.release_date }}.md`
            - Updated sidebar navigation in `about_all_sidebar.yml`
            
            Please review and merge. ‚úÖ
          labels: "automation"
          base: master